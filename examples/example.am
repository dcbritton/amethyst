
# definition of matrix type
type Matrix

    # member declarations
    @data:int**
    @size:int

    # constructor, allocates size x size int matrix on heap
    new(size:int)
        @size = size

        if size != 0 then
            @data = @allocateNxN(@size)
        end
        return
    end

    # method, set each entry to be the product of its indices
    def @setEntriesToIndexProduct()
        i:int = 0
        while i != @size do
            j:int = 0
            while j != @size do
                @data[i][j] = i * j
                j = j + 1
            end
            i = i + 1
        end
        return
    end

    # method, get a deep copy of this matrix
    def @deepCopy():Matrix

        result:Matrix = new Matrix(@size)

        i:int = 0
        while i != @size do
            j:int = 0
            while j != @size do
                result.data[i][j] = @data[i][j]
                j = j + 1
            end
            i = i + 1
        end

        return result
    end

    # method to allocate an nxn on heap
    # returns a ptr to the matrix int**
    def @allocateNxN(n:int):int**
        rows:int** = heap [n] int*
        i:int = 0
        while i != n do
            rows[i] = heap [n] int
            i = i + 1
        end

        return rows
    end

    # operator to add corresponing entries of matrices of the same size
    # returns a new matrix with heap allocation
    op+(rhs:Matrix):Matrix

        # if sizes don't match, do no allocation and return a matrix of size zero
        if @size != rhs.size then
            return new Matrix(0)
        end

        # sizes match, add corresponding entries
        result:Matrix = @deepCopy()

        i:int = 0
        while i != @size do
            j:int = 0
            while j != @size do
                result.data[i][j] = result.data[i][j] + rhs.data[i][j]
                j = j + 1
            end
            i = i + 1
        end

        return result
    end

    # operator to multiply matrices (standard matrix multiplication)
    # returns a new matrix with heap allocation
    op*(rhs:Matrix):Matrix

        # if sizes don't match, do no allocation and return a matrix of size zero
        if @size != rhs.size then
            return new Matrix(0)
        end

        # sizes match, perform matrix multiplication
        result:Matrix = new Matrix(@size)

        i:int = 0
        while i != @size do
            j:int = 0
            while j != @size do
                # Calculate the dot product of row i of the left-hand matrix 
                # and column j of the right-hand matrix
                result.data[i][j] = 0  # Initialize the result entry to zero
                k:int = 0
                while k != @size do
                    result.data[i][j] = result.data[i][j] + @data[i][k] * rhs.data[k][j]
                    k = k + 1
                end
                j = j + 1
            end
            i = i + 1
        end

        return result
    end

    # simple destructor to free a matrix's memory
    def @destroy()
        i:int = 0
        while i != @size do
            unheap @data[i]
            i = i + 1
        end
        unheap @data

        return
    end
end

# global type test
$mat:Matrix

# testing in main
def main():int
    
    mat:Matrix = new Matrix(8)
    mat.setEntriesToIndexProduct()
    # return mat.data[mat.size-1][mat.size-1]

    $mat = mat.deepCopy()

    matSum:Matrix = mat * $mat + mat
    k:int = matSum.data[mat.size-1][mat.size-1]

    mat.destroy()
    $mat.destroy()
    matSum.destroy()

    a:float = 1.234
    b:float = 1.234

    if a != b then
        return 123
    else then
        return 124
    end

    return k
end
